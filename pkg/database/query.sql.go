// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"shantaram/app/api"
)

const countOrders = `-- name: CountOrders :one
SELECT COUNT(*)
FROM orders
`

// CountOrders
//
//	SELECT COUNT(*)
//	FROM orders
func (q *Queries) CountOrders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMigration = `-- name: CreateMigration :one
INSERT INTO migration (id, applied)
VALUES ($1, $2) RETURNING id
`

type CreateMigrationParams struct {
	ID      string
	Applied time.Time
}

// CreateMigration
//
//	INSERT INTO migration (id, applied)
//	VALUES ($1, $2) RETURNING id
func (q *Queries) CreateMigration(ctx context.Context, arg CreateMigrationParams) (string, error) {
	row := q.db.QueryRow(ctx, createMigration, arg.ID, arg.Applied)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (id, table_id, client_name, client_comment, status, seen, items)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, index, table_id, created, updated, status, client_name, client_comment, seen, items
`

type CreateOrderParams struct {
	ID            uuid.UUID
	TableID       *string
	ClientName    string
	ClientComment *string
	Status        api.OrderStatus
	Seen          bool
	Items         []api.OrderItem
}

// CreateOrder
//
//	INSERT INTO orders (id, table_id, client_name, client_comment, status, seen, items)
//	VALUES ($1, $2, $3, $4, $5, $6, $7)
//	RETURNING id, index, table_id, created, updated, status, client_name, client_comment, seen, items
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.ID,
		arg.TableID,
		arg.ClientName,
		arg.ClientComment,
		arg.Status,
		arg.Seen,
		arg.Items,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Index,
		&i.TableID,
		&i.Created,
		&i.Updated,
		&i.Status,
		&i.ClientName,
		&i.ClientComment,
		&i.Seen,
		&i.Items,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :exec
INSERT INTO products (id, group_id, title, description, price, index)
VALUES ($1, $2::UUID, $3, $4, $5,
        (SELECT COALESCE(MAX(index), 0) + 1 FROM products WHERE group_id = $2::UUID) )
`

type CreateProductParams struct {
	ID          uuid.UUID
	GroupID     uuid.UUID
	Title       string
	Description string
	Price       float64
}

// CreateProduct
//
//	INSERT INTO products (id, group_id, title, description, price, index)
//	VALUES ($1, $2::UUID, $3, $4, $5,
//	        (SELECT COALESCE(MAX(index), 0) + 1 FROM products WHERE group_id = $2::UUID) )
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) error {
	_, err := q.db.Exec(ctx, createProduct,
		arg.ID,
		arg.GroupID,
		arg.Title,
		arg.Description,
		arg.Price,
	)
	return err
}

const createProductGroup = `-- name: CreateProductGroup :exec
INSERT INTO product_groups (id, menu_id, title, index)
VALUES ($1, $2::VARCHAR(255), $3,
        (SELECT COALESCE(MAX(index), 0) + 1 FROM product_groups WHERE menu_id = $2:: VARCHAR (255)) )
`

type CreateProductGroupParams struct {
	ID     uuid.UUID
	MenuID string
	Title  string
}

// CreateProductGroup
//
//	INSERT INTO product_groups (id, menu_id, title, index)
//	VALUES ($1, $2::VARCHAR(255), $3,
//	        (SELECT COALESCE(MAX(index), 0) + 1 FROM product_groups WHERE menu_id = $2:: VARCHAR (255)) )
func (q *Queries) CreateProductGroup(ctx context.Context, arg CreateProductGroupParams) error {
	_, err := q.db.Exec(ctx, createProductGroup, arg.ID, arg.MenuID, arg.Title)
	return err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE
FROM orders
WHERE id = $1
`

// DeleteOrder
//
//	DELETE
//	FROM orders
//	WHERE id = $1
func (q *Queries) DeleteOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE
FROM products
WHERE id = $1
`

// DeleteProduct
//
//	DELETE
//	FROM products
//	WHERE id = $1
func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteProductGroup = `-- name: DeleteProductGroup :exec
DELETE
FROM product_groups
WHERE id = $1
`

// DeleteProductGroup
//
//	DELETE
//	FROM product_groups
//	WHERE id = $1
func (q *Queries) DeleteProductGroup(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductGroup, id)
	return err
}

const getAllProductGroups = `-- name: GetAllProductGroups :many
SELECT id, menu_id, index, title, created, updated
FROM product_groups
ORDER BY index
`

// GetAllProductGroups
//
//	SELECT id, menu_id, index, title, created, updated
//	FROM product_groups
//	ORDER BY index
func (q *Queries) GetAllProductGroups(ctx context.Context) ([]ProductGroup, error) {
	rows, err := q.db.Query(ctx, getAllProductGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductGroup{}
	for rows.Next() {
		var i ProductGroup
		if err := rows.Scan(
			&i.ID,
			&i.MenuID,
			&i.Index,
			&i.Title,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProducts = `-- name: GetAllProducts :many
SELECT id, group_id, index, title, description, price, available, created, updated
FROM products
ORDER BY available DESC, index, group_id
`

// GetAllProducts
//
//	SELECT id, group_id, index, title, description, price, available, created, updated
//	FROM products
//	ORDER BY available DESC, index, group_id
func (q *Queries) GetAllProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.Query(ctx, getAllProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Index,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Available,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMenus = `-- name: GetMenus :many
SELECT id, title, created
FROM menu
ORDER BY created
`

// GetMenus
//
//	SELECT id, title, created
//	FROM menu
//	ORDER BY created
func (q *Queries) GetMenus(ctx context.Context) ([]Menu, error) {
	rows, err := q.db.Query(ctx, getMenus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Menu{}
	for rows.Next() {
		var i Menu
		if err := rows.Scan(&i.ID, &i.Title, &i.Created); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMigrations = `-- name: GetMigrations :many
SELECT id, applied
FROM migration
ORDER BY id
`

// GetMigrations
//
//	SELECT id, applied
//	FROM migration
//	ORDER BY id
func (q *Queries) GetMigrations(ctx context.Context) ([]Migration, error) {
	rows, err := q.db.Query(ctx, getMigrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Migration{}
	for rows.Next() {
		var i Migration
		if err := rows.Scan(&i.ID, &i.Applied); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, index, table_id, created, updated, status, client_name, client_comment, seen, items
FROM orders
WHERE id = $1
`

// GetOrderByID
//
//	SELECT id, index, table_id, created, updated, status, client_name, client_comment, seen, items
//	FROM orders
//	WHERE id = $1
func (q *Queries) GetOrderByID(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Index,
		&i.TableID,
		&i.Created,
		&i.Updated,
		&i.Status,
		&i.ClientName,
		&i.ClientComment,
		&i.Seen,
		&i.Items,
	)
	return i, err
}

const getOrdersPaginated = `-- name: GetOrdersPaginated :many
SELECT id, index, table_id, created, updated, status, client_name, client_comment, seen, items
FROM orders
ORDER BY index DESC
OFFSET $1 LIMIT $2
`

type GetOrdersPaginatedParams struct {
	Offset int64
	Limit  int64
}

// GetOrdersPaginated
//
//	SELECT id, index, table_id, created, updated, status, client_name, client_comment, seen, items
//	FROM orders
//	ORDER BY index DESC
//	OFFSET $1 LIMIT $2
func (q *Queries) GetOrdersPaginated(ctx context.Context, arg GetOrdersPaginatedParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersPaginated, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Index,
			&i.TableID,
			&i.Created,
			&i.Updated,
			&i.Status,
			&i.ClientName,
			&i.ClientComment,
			&i.Seen,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParams = `-- name: GetParams :one
SELECT id, header_text, header_deadline
FROM params
WHERE id = 1
`

// GetParams
//
//	SELECT id, header_text, header_deadline
//	FROM params
//	WHERE id = 1
func (q *Queries) GetParams(ctx context.Context) (Param, error) {
	row := q.db.QueryRow(ctx, getParams)
	var i Param
	err := row.Scan(&i.ID, &i.HeaderText, &i.HeaderDeadline)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, group_id, index, title, description, price, available, created, updated
FROM products
WHERE id = $1
`

// GetProductByID
//
//	SELECT id, group_id, index, title, description, price, available, created, updated
//	FROM products
//	WHERE id = $1
func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Index,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Available,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getProductGroupByID = `-- name: GetProductGroupByID :one
SELECT id, menu_id, index, title, created, updated
FROM product_groups
WHERE id = $1
`

// GetProductGroupByID
//
//	SELECT id, menu_id, index, title, created, updated
//	FROM product_groups
//	WHERE id = $1
func (q *Queries) GetProductGroupByID(ctx context.Context, id uuid.UUID) (ProductGroup, error) {
	row := q.db.QueryRow(ctx, getProductGroupByID, id)
	var i ProductGroup
	err := row.Scan(
		&i.ID,
		&i.MenuID,
		&i.Index,
		&i.Title,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getProductsByGroup = `-- name: GetProductsByGroup :many
SELECT id, group_id, index, title, description, price, available, created, updated
FROM products
WHERE group_id = $1
ORDER BY index
`

// GetProductsByGroup
//
//	SELECT id, group_id, index, title, description, price, available, created, updated
//	FROM products
//	WHERE group_id = $1
//	ORDER BY index
func (q *Queries) GetProductsByGroup(ctx context.Context, groupID uuid.UUID) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Index,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Available,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, group_id, index, title, description, price, available, created, updated
FROM products
WHERE (title ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%')
  AND available = true
ORDER BY title
`

// SearchProducts
//
//	SELECT id, group_id, index, title, description, price, available, created, updated
//	FROM products
//	WHERE (title ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%')
//	  AND available = true
//	ORDER BY title
func (q *Queries) SearchProducts(ctx context.Context, dollar_1 *string) ([]Product, error) {
	rows, err := q.db.Query(ctx, searchProducts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Index,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Available,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setOrderSeen = `-- name: SetOrderSeen :exec
UPDATE orders
SET seen    = true,
    updated = CURRENT_TIMESTAMP
WHERE id = $1
`

// SetOrderSeen
//
//	UPDATE orders
//	SET seen    = true,
//	    updated = CURRENT_TIMESTAMP
//	WHERE id = $1
func (q *Queries) SetOrderSeen(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, setOrderSeen, id)
	return err
}

const setParamsHeader = `-- name: SetParamsHeader :exec
UPDATE params
SET header_text = $1,
    header_deadline = $2
WHERE id = 1
`

type SetParamsHeaderParams struct {
	HeaderText     *string
	HeaderDeadline *time.Time
}

// SetParamsHeader
//
//	UPDATE params
//	SET header_text = $1,
//	    header_deadline = $2
//	WHERE id = 1
func (q *Queries) SetParamsHeader(ctx context.Context, arg SetParamsHeaderParams) error {
	_, err := q.db.Exec(ctx, setParamsHeader, arg.HeaderText, arg.HeaderDeadline)
	return err
}

const setProductAvailability = `-- name: SetProductAvailability :exec
UPDATE products
SET available = $2,
    updated   = CURRENT_TIMESTAMP
WHERE id = $1
`

type SetProductAvailabilityParams struct {
	ID        uuid.UUID
	Available bool
}

// SetProductAvailability
//
//	UPDATE products
//	SET available = $2,
//	    updated   = CURRENT_TIMESTAMP
//	WHERE id = $1
func (q *Queries) SetProductAvailability(ctx context.Context, arg SetProductAvailabilityParams) error {
	_, err := q.db.Exec(ctx, setProductAvailability, arg.ID, arg.Available)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders
SET status  = $2,
    updated = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateOrderStatusParams struct {
	ID     uuid.UUID
	Status api.OrderStatus
}

// UpdateOrderStatus
//
//	UPDATE orders
//	SET status  = $2,
//	    updated = CURRENT_TIMESTAMP
//	WHERE id = $1
func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderStatus, arg.ID, arg.Status)
	return err
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE products
SET title       = $2,
    description = $3,
    price       = $4,
    available   = $5,
    updated     = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateProductParams struct {
	ID          uuid.UUID
	Title       string
	Description string
	Price       float64
	Available   bool
}

// UpdateProduct
//
//	UPDATE products
//	SET title       = $2,
//	    description = $3,
//	    price       = $4,
//	    available   = $5,
//	    updated     = CURRENT_TIMESTAMP
//	WHERE id = $1
func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, updateProduct,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Price,
		arg.Available,
	)
	return err
}

const updateProductGroup = `-- name: UpdateProductGroup :exec
UPDATE product_groups
SET title   = $2,
    updated = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateProductGroupParams struct {
	ID    uuid.UUID
	Title string
}

// UpdateProductGroup
//
//	UPDATE product_groups
//	SET title   = $2,
//	    updated = CURRENT_TIMESTAMP
//	WHERE id = $1
func (q *Queries) UpdateProductGroup(ctx context.Context, arg UpdateProductGroupParams) error {
	_, err := q.db.Exec(ctx, updateProductGroup, arg.ID, arg.Title)
	return err
}

const updateProductGroupIndex = `-- name: UpdateProductGroupIndex :exec
UPDATE product_groups
SET index   = $2,
    updated = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateProductGroupIndexParams struct {
	ID    uuid.UUID
	Index int32
}

// UpdateProductGroupIndex
//
//	UPDATE product_groups
//	SET index   = $2,
//	    updated = CURRENT_TIMESTAMP
//	WHERE id = $1
func (q *Queries) UpdateProductGroupIndex(ctx context.Context, arg UpdateProductGroupIndexParams) error {
	_, err := q.db.Exec(ctx, updateProductGroupIndex, arg.ID, arg.Index)
	return err
}

const updateProductIndex = `-- name: UpdateProductIndex :exec
UPDATE products
SET index   = $2,
    updated = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateProductIndexParams struct {
	ID    uuid.UUID
	Index int32
}

// UpdateProductIndex
//
//	UPDATE products
//	SET index   = $2,
//	    updated = CURRENT_TIMESTAMP
//	WHERE id = $1
func (q *Queries) UpdateProductIndex(ctx context.Context, arg UpdateProductIndexParams) error {
	_, err := q.db.Exec(ctx, updateProductIndex, arg.ID, arg.Index)
	return err
}
